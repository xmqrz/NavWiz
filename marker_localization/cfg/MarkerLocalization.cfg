#!/usr/bin/env python
PACKAGE = 'marker_localization'

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

# Reflector
reflector = gen.add_group("Reflector")
for i in range(1, 6):
    reflector_i = reflector.add_group("Reflector %d" % i)
    reflector_i.add("reflector_intensity_threshold%d" % i, double_t, 0, "Minimum laser intensity when reflected from the reflector surface.", 5000.0, 0)
    reflector_i.add("reflector_min_width%d" % i, double_t, 0, "Minimum width (m) of the reflectors.", 0.05, 0, 0.5)
    reflector_i.add("reflector_max_width%d" % i, double_t, 0, "Maximum width (m) of the reflectors.", 0.15, 0, 0.5)
    reflector_i.add("reflector_radius%d" % i, double_t, 0, "Radius (m) of the cylinder reflectors. 0 for flat reflectors.", 0, 0, 0.5)
    reflector_i.add("reflector_min_separation%d" % i, double_t, 0, "Minimum separation (m) between the reflectors.", 0.2, 0, 5.0)
    reflector_i.add("reflector_max_separation%d" % i, double_t, 0, "Maximum separation (m) between the reflectors.", 0.8, 0, 5.0)
    reflector_i.add("reflector_max_position_deviation%d" % i, double_t, 0, "Maximum deviation distance (m) between new marker position and the previous detected position. Disabled if zero", 0.3, 0, 100.0)

# Line Marker
line_marker = gen.add_group('Line Marker')

# Line Extraction
line_extraction = line_marker.add_group('Line Extraction')
line_extraction.add('bearing_std_dev', double_t, 0, 'The standard deviation of bearing uncertainty in the laser scans (rad)', 1e-5, 0.0, 1.0)
line_extraction.add('range_std_dev', double_t, 0, 'The standard deviation of range uncertainty in the laser scans (m)', 0.02, 0.0, 1.0)
line_extraction.add('least_sq_angle_thresh', double_t, 0, 'Change in angle (rad) threshold to stop iterating least squares (least_sq_radius_thresh must also be met)', 1e-3, 0.0, 1.0)
line_extraction.add('least_sq_radius_thresh', double_t, 0, 'Change in radius (m) threshold to stop iterating least squares (least_sq_angle_thresh must also be met)', 1e-3, 0.0, 1.0)
line_extraction.add('max_line_gap', double_t, 0, 'The maximum distance between two points in the same line (m)', 0.5, 0.0, 1.0)
line_extraction.add('min_line_points', int_t, 0, 'Lines with fewer points than this are not published', 5, 2, 10000)
line_extraction.add('min_line_length', double_t, 0, 'Lines shorter than this are not used (m)', 0.03, 0.0, 1.0)
line_extraction.add('min_range', double_t, 0, 'Points closer than this are ignored (m)', 0.1, 0.0, 1.0)
line_extraction.add('max_range', double_t, 0, 'Points further than this are ignored (m)', 5.0, 0.0, 100.0)
line_extraction.add('min_split_dist', double_t, 0, 'When performing \'split\' step of split and merge, ' +
    'a split between two points results when the two points are at least this far apart (m)', 0.04, 0.0, 1.0)
line_extraction.add('outlier_dist', double_t, 0, 'Points who are at least this distance from all their neighbours are considered outliers (m)', 0.04, 0.0, 1.0)

line_extraction.add('max_intercept_distance', double_t, 0, 'Maximum distance where 2 lines should intercept in meter', 0.05, 0.0, 1.0)
line_extraction.add('publish_visualization', bool_t, 0, 'Publish visualization topic', False)

# V Extraction
v_extraction = line_marker.add_group('V Extraction')
for i in range(1, 6):
    v_extraction_i = v_extraction.add_group('V Extraction %d' % i)
    v_extraction_i.add('min_v_angle%d' % i, double_t, 0, 'Minimum V angle in degree', 110.0, 0.0, 180.0)
    v_extraction_i.add('max_v_angle%d' % i, double_t, 0, 'Maximum V angle in degree', 130.0, 0.0, 180.0)
    v_extraction_i.add('min_v_length%d' % i, double_t, 0, 'Minimum V length in meter', 0.1, 0.0, 30.0)
    v_extraction_i.add('max_v_length%d' % i, double_t, 0, 'Maximum V length in meter', 0.3, 0.0, 30.0)
    v_extraction_i.add('max_v_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# L Extraction
l_extraction = line_marker.add_group('L Extraction')
for i in range(1, 6):
    l_extraction_i = l_extraction.add_group('L Extraction %d' % i)
    l_extraction_i.add('min_l_angle%d' % i, double_t, 0, 'Minimum L angle in degree', 110.0, 0.0, 180.0)
    l_extraction_i.add('max_l_angle%d' % i, double_t, 0, 'Maximum L angle in degree', 130.0, 0.0, 180.0)
    l_extraction_i.add('min_l_length%d' % i, double_t, 0, 'Minimum L length in meter', 0.1, 0.0, 30.0)
    l_extraction_i.add('max_l_length%d' % i, double_t, 0, 'Maximum L length in meter', 0.3, 0.0, 30.0)
    l_extraction_i.add('max_l_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# VL Extraction
vl_extraction = line_marker.add_group('V L Extraction')
for i in range(1, 6):
    vl_extraction_i = vl_extraction.add_group('V L Extraction %d' % i)
    vl_extraction_i.add('min_vl_v_angle%d' % i, double_t, 0, 'Minimum V angle in degree', 110.0, 0.0, 180.0)
    vl_extraction_i.add('max_vl_v_angle%d' % i, double_t, 0, 'Maximum V angle in degree', 130.0, 0.0, 180.0)
    vl_extraction_i.add('min_vl_l_angle%d' % i, double_t, 0, 'Minimum L angle in degree', 110.0, 0.0, 180.0)
    vl_extraction_i.add('max_vl_l_angle%d' % i, double_t, 0, 'Maximum L angle in degree', 130.0, 0.0, 180.0)
    vl_extraction_i.add('min_vl_length%d' % i, double_t, 0, 'Minimum VL length in meter', 0.1, 0.0, 30.0)
    vl_extraction_i.add('max_vl_length%d' % i, double_t, 0, 'Maximum VL length in meter', 0.3, 0.0, 30.0)
    vl_extraction_i.add('max_vl_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# V-Pair Extraction
v2_extraction = line_marker.add_group('V Pair Extraction')
for i in range(1, 6):
    v2_extraction_i = v2_extraction.add_group('V Pair Extraction %d' % i)
    v2_extraction_i.add('min_v2_angle%d' % i, double_t, 0, 'Minimum V angle in degree', 110.0, 0.0, 180.0)
    v2_extraction_i.add('max_v2_angle%d' % i, double_t, 0, 'Maximum V angle in degree', 130.0, 0.0, 180.0)
    v2_extraction_i.add('min_v2_length%d' % i, double_t, 0, 'Minimum V length in meter', 0.1, 0.0, 30.0)
    v2_extraction_i.add('max_v2_length%d' % i, double_t, 0, 'Maximum V length in meter', 0.3, 0.0, 30.0)
    v2_extraction_i.add('min_v2_separation%d' % i, double_t, 0, 'Minimum separation between the pair in meter', 0.75, 0, 5.0)
    v2_extraction_i.add('max_v2_separation%d' % i, double_t, 0, 'Maximum separation between the pair in meter', 1.5, 0, 5.0)
    v2_extraction_i.add('max_v2_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# L-Pair Extraction
l2_extraction = line_marker.add_group('L Pair Extraction')
for i in range(1, 6):
    l2_extraction_i = l2_extraction.add_group('L Pair Extraction %d' % i)
    l2_extraction_i.add('min_l2_angle%d' % i, double_t, 0, 'Minimum L angle in degree', 110.0, 0.0, 180.0)
    l2_extraction_i.add('max_l2_angle%d' % i, double_t, 0, 'Maximum L angle in degree', 130.0, 0.0, 180.0)
    l2_extraction_i.add('min_l2_length%d' % i, double_t, 0, 'Minimum L length in meter', 0.1, 0.0, 30.0)
    l2_extraction_i.add('max_l2_length%d' % i, double_t, 0, 'Maximum L length in meter', 0.3, 0.0, 30.0)
    l2_extraction_i.add('min_l2_separation%d' % i, double_t, 0, 'Minimum separation between the pair in meter', 0.75, 0, 5.0)
    l2_extraction_i.add('max_l2_separation%d' % i, double_t, 0, 'Maximum separation between the pair in meter', 1.5, 0, 5.0)
    l2_extraction_i.add('max_l2_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# Bar Extraction
bar_extraction = line_marker.add_group('Bar Extraction')
for i in range(1, 6):
    bar_extraction_i = bar_extraction.add_group('Bar Extraction %d' % i)
    bar_extraction_i.add('min_bar_length%d' % i, double_t, 0, 'Minimum Bar length in meter', 0.4, 0.0, 30.0)
    bar_extraction_i.add('max_bar_length%d' % i, double_t, 0, 'Maximum Bar length in meter', 0.75, 0.0, 30.0)
    bar_extraction_i.add('min_bar_separation%d' % i, double_t, 0, 'Minimum separation between the pair in meter', 0.75, 0, 5.0)
    bar_extraction_i.add('max_bar_separation%d' % i, double_t, 0, 'Maximum separation between the pair in meter', 1.5, 0, 5.0)
    bar_extraction_i.add('max_bar_pair_angle%d' % i, double_t, 0, 'Maximum angle between the pair in degree', 15.0, 0.0, 90.0)
    bar_extraction_i.add('max_bar_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# Bar Reflector
bar_reflector = line_marker.add_group('Bar Reflector')
for i in range(1, 6):
    bar_reflector_i = bar_reflector.add_group('Bar Reflector %d' % i)
    bar_reflector_i.add('bar_reflector_intensity_threshold%d' % i, double_t, 0, 'Minimum laser intensity when reflected from the reflector surface', 5000.0, 0)
    bar_reflector_i.add('bar_reflector_min_width%d' % i, double_t, 0, 'Minimum width (m) of the reflectors', 0.05, 0, 0.5)
    bar_reflector_i.add('bar_reflector_max_width%d' % i, double_t, 0, 'Maximum width (m) of the reflectors', 0.15, 0, 0.5)
    bar_reflector_i.add('bar_reflector_radius%d' % i, double_t, 0, 'Radius (m) of the cylinder reflectors. 0 for flat reflectors', 0, 0, 0.5)
    bar_reflector_i.add('bar_reflector_min_angle%d' % i, double_t, 0, 'Minimum angle of marker heading from sensor origin in degree', -180.0, -180.0, 360.0)
    bar_reflector_i.add('bar_reflector_max_angle%d' % i, double_t, 0, 'Maximum angle of marker heading from sensor origin in degree', 360.0, -180.0, 360.0)
    bar_reflector_i.add('bar_reflector_min_length%d' % i, double_t, 0, 'Minimum Bar length in meter', 0.4, 0.0, 30.0)
    bar_reflector_i.add('bar_reflector_max_length%d' % i, double_t, 0, 'Maximum Bar length in meter', 0.75, 0.0, 30.0)
    bar_reflector_i.add('bar_reflector_max_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# Bar AR
bar_ar = line_marker.add_group('Bar AR')
for i in range(1, 6):
    bar_ar_i = bar_ar.add_group('Bar AR %d' % i)
    bar_ar_i.add('bar_ar_ext_heading%d' % i, double_t, 0, 'External heading offset (rad). Disabled external heading if negative', -1.0, -1.0, 6.2832)
    bar_ar_i.add('bar_ar_image_is_rectified%d' % i, bool_t, 0, 'Image is rectified or not', True)
    bar_ar_i.add('bar_ar_sharp_strength%d' % i, double_t, 0, 'Image sharpening strength. Disabled if zero', 0.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_sharp_sigma%d' % i, double_t, 0, 'Image sharpening sigma', 10.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_height_start%d' % i, double_t, 0, 'Region of interest height start (%)', 0.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_height_end%d' % i, double_t, 0, 'Region of interest height end (%)', 0.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_width_start%d' % i, double_t, 0, 'Region of interest width start (%)', 0.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_width_end%d' % i, double_t, 0, 'Region of interest width end (%)', 0.0, 0.0, 100.0)
    bar_ar_i.add('bar_ar_marker_size%d' % i, double_t, 0, 'AR marker size (m)', 0.035, 0.0, 1.0)
    bar_ar_i.add('bar_ar_max_gap%d' % i, double_t, 0, 'Maximum gap size (m) in between Bar and AR marker', 0.1, 0.0, 5.0)
    bar_ar_i.add('bar_ar_min_angle%d' % i, double_t, 0, 'Minimum angle of marker heading from laser sensor origin in degree', -180.0, -180.0, 360.0)
    bar_ar_i.add('bar_ar_max_angle%d' % i, double_t, 0, 'Maximum angle of marker heading from laser sensor origin in degree', 360.0, -180.0, 360.0)
    bar_ar_i.add('bar_ar_min_length%d' % i, double_t, 0, 'Minimum Bar length in meter', 0.4, 0.0, 30.0)
    bar_ar_i.add('bar_ar_max_length%d' % i, double_t, 0, 'Maximum Bar length in meter', 0.75, 0.0, 30.0)
    bar_ar_i.add('bar_ar_max_translational_deviation%d' % i, double_t, 0, 'Maximum marker translational deviation in meter', 0.3, 0.0, 100.0)

# AR Marker
ar = gen.add_group('AR Marker')
for i in range(1, 6):
    ar_i = ar.add_group("AR %d" % i)
    ar_i.add("ar_image_is_rectified%d" % i, bool_t, 0, 'Image is rectified or not', True)
    ar_i.add("ar_sharp_strength%d" % i, double_t, 0, 'Image sharpening strength. Disabled if zero', 0.0, 0.0, 100.0)
    ar_i.add("ar_sharp_sigma%d" % i, double_t, 0, 'Image sharpening sigma', 10.0, 0.0, 100.0)
    ar_i.add("ar_height_start%d" % i, double_t, 0, 'Region of interest height start (%)', 0.0, 0.0, 100.0)
    ar_i.add("ar_height_end%d" % i, double_t, 0, 'Region of interest height end (%)', 0.0, 0.0, 100.0)
    ar_i.add("ar_width_start%d" % i, double_t, 0, 'Region of interest width start (%)', 0.0, 0.0, 100.0)
    ar_i.add("ar_width_end%d" % i, double_t, 0, 'Region of interest width end (%)', 0.0, 0.0, 100.0)
    ar_i.add("ar_marker_size%d" % i, double_t, 0, 'AR marker size (m)', 0.035, 0.0, 1.0)
    ar_i.add("ar_min_separation%d" % i, double_t, 0, "Minimum separation (m) between the AR markers", 0.2, 0, 5.0)
    ar_i.add("ar_max_separation%d" % i, double_t, 0, "Maximum separation (m) between the AR markers", 0.8, 0, 5.0)
    ar_i.add("ar_max_position_deviation%d" % i, double_t, 0, "Maximum deviation distance (m) between new marker position and the previous detected position. Disabled if zero", 0.3, 0, 100.0)

# Pallet
pallet = gen.add_group('Pallet')
for i in range(1, 6):
    s = "_%d" % i if i > 1 else ""
    pallet_i = pallet.add_group("Pallet %d" % i)
    pallet_i.add("pallet_crop_z_min%s" % s, double_t, 0, "Minimum z value allowed through the filter (m)", 0.02, -1.0, 1.0)
    pallet_i.add("pallet_crop_z_max%s" % s, double_t, 0, "Maximum z value allowed through the filter (m)", 0.18, -1.0, 1.0)
    pallet_i.add("pallet_block_height_min%s" % s, double_t, 0, "Minimum height of the pallet block (m)", 0.1, 0.01, 1.0)
    pallet_i.add("pallet_block_height_max%s" % s, double_t, 0, "Maximum height of the pallet block (m)", 0.2, 0.01, 1.0)
    pallet_i.add("pallet_block_width_min%s" % s, double_t, 0, "Minimum width of the pallet block (m)", 0.05, 0.01, 1.0)
    pallet_i.add("pallet_block_width_max%s" % s, double_t, 0, "Maximum width of the pallet block (m)", 0.15, 0.01, 1.0)
    pallet_i.add("pallet_block_vertical_angle_min%s" % s, double_t, 0, "Minimum angle between the pallet block's front surface and the vertical plane (deg)", -25, -90, 90)
    pallet_i.add("pallet_block_vertical_angle_max%s" % s, double_t, 0, "Maximum angle between the pallet block's front surface and the vertical plane (deg)", 25, -90, 90)
    pallet_i.add("pallet_block_smoothness_angle%s" % s, double_t, 0, "Maximum angle between the points on the pallet block's front surface allowed through the smoothness filter (deg)", 10, 0, 90)
    pallet_i.add("pallet_pocket_count%s" % s, int_t, 0, "Number of pallet pockets", 2, 1, 2)
    pallet_i.add("pallet_blocks_distance_min%s" % s, double_t, 0, "Minimum width of pallet pockets (m)", 0.4, 0.1, 2.0)
    pallet_i.add("pallet_blocks_distance_max%s" % s, double_t, 0, "Maximum width of pallet pockets (m)", 0.5, 0.1, 2.0)
    pallet_i.add("pallet_blocks_alignment_angle%s" % s, double_t, 0, "Maximum angle between the line joining the center and two side blocks (deg)", 10, 0, 90)
    pallet_i.add("pallet_center_block_line_fitting_max_error%s" % s, double_t, 0, "Maximum line fitting error of the center block (m). Disabled if zero", 0.04, 0, 0.3)
    pallet_i.add("pallet_deck_line_fitting_max_error%s" % s, double_t, 0, "Maximum line fitting error to the pallet deck (m). Disabled if zero", 0, 0, 0.3)
    pallet_i.add("pallet_first_position_max%s" % s, double_t, 0, "Maximum y-axis offset of the first detection (m). Disabled if zero", 0, 0, 10)
    pallet_i.add("pallet_first_orientation_max%s" % s, double_t, 0, "Maximum orientation of the first detection (deg). Disabled if zero", 0, 0, 180)
    pallet_i.add("pallet_position_deviation_max%s" % s, double_t, 0, "Maximum distance between the new pallet position and the previous detected position (m). Disabled if zero", 0.3, 0, 100.0)

# Image Pallet
image_pallet = gen.add_group('Image Pallet')
image_pallet.add("pallet_cascade_name", str_t, 0, "Specify the pallet cascade to be used", "/home/df/ws_zetha/src/marker_localization/xml/pallet_cascade.xml")
image_pallet.add("template_path", str_t, 0, "Specify the template to be used", "/home/df/ws_zetha/src/marker_localization/xml/test_template.jpg")
image_pallet.add("mask_path", str_t, 0, "Specify the mask to be used", "/home/df/zetha/src/marker_localization/xml/test_template.jpg")

# Common
common = gen.add_group('Common')
common.add("mean_filter_window", int_t, 0, "The number of marker data to be used to calculate the moving average of the marker 2D pose", 16, 1, 64)
common.add("position_deviation_max", double_t, 0, "Maximum distance between the current position and the first detected position (m). Disabled if zero", 0, 0, 10)
common.add("orientation_deviation_max", double_t, 0, "Maximum angle between the current orientation and the first detected orientation (deg). Disabled if zero", 0, 0, 180)

# End
exit(gen.generate(PACKAGE, "marker_localization", "MarkerLocalization"))
