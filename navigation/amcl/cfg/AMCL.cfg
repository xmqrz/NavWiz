#!/usr/bin/env python

PACKAGE = 'amcl'

from math import pi
from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, int_t, double_t, str_t, bool_t

gen = ParameterGenerator()

# AMCL
amcl = gen.add_group("AMCL")

amcl.add("min_particles", int_t, 0, "Minimum allowed number of particles.", 100, 0, 1000)
amcl.add("max_particles", int_t, 0, "Mamimum allowed number of particles.", 5000, 0, 10000)

amcl.add("kld_err",  double_t, 0, "Maximum error between the true distribution and the estimated distribution.", .01, 0, 1)
amcl.add("kld_z", double_t, 0, "Upper standard normal quantile for (1 - p), where p is the probability that the error on the estimated distribution will be less than kld_err.", .99, 0, 1)

amcl.add("update_min_d", double_t, 0, "Translational movement required before performing a filter update.", .2, 0, 5)
amcl.add("update_min_a", double_t, 0, "Rotational movement required before performing a filter update.", pi/6, 0, 2*pi)

amcl.add("resample_interval", int_t, 0, "Number of filter updates required before resampling.", 2, 0, 20)
amcl.add("selective_resampling", bool_t, 0, "Whether to enable adaptive resampling.", False)

amcl.add("recovery_alpha_slow", double_t, 0, "Exponential decay rate for the slow average weight filter, used in deciding when to recover by adding random poses. A good value might be 0.001.", 0, 0, .5)
amcl.add("recovery_alpha_fast", double_t, 0, "Exponential decay rate for the fast average weight filter, used in deciding when to recover by adding random poses. A good value might be 0.1.", 0, 0, 1)

amcl.add("do_beamskip", bool_t, 0, "When true skips laser scans when a scan doesnt work for a majority of particles", False)
amcl.add("beam_skip_distance", double_t, 0, "Distance from a valid map point before scan is considered invalid", 0.5, 0, 2)
amcl.add("beam_skip_threshold", double_t, 0, "Ratio of samples for which the scans are valid to consider as valid scan", 0.3, 0, 1)
amcl.add("beam_skip_error_threshold", double_t, 0, "Ratio of skipped beams above which it indicates a wrong convergence, so in that case all the beams will be integrated in the hope that the filter might converge to the right solution", 0.9, 0, 1)

amcl.add("tf_broadcast", bool_t, 0, "When true (the default), publish results via TF.  When false, do not.", True)
amcl.add("force_update_after_initialpose", bool_t, 0, "When true, force a pose update after a new /initialpose is received.", False)
amcl.add("force_update_after_set_map", bool_t, 0, "When true, force a pose update after a new map (and pose) has been set via the /set_map service.", False)
amcl.add("save_pose_rate", double_t, 0, "Maximum rate (Hz) at which to store the last estimated pose and covariance to the parameter server, in the variables ~initial_pose_* and ~initial_cov_*. This saved pose will be used on subsequent runs to initialize the filter. -1.0 to disable.", .5, -1, 10)

# Laser Model Parameters
amcl.add("laser_min_range", double_t, 0, "Minimum scan range to be considered; -1.0 will cause the laser's reported minimum range to be used.", -1, -1, 1000)
amcl.add("laser_max_range", double_t, 0, "Maximum scan range to be considered; -1.0 will cause the laser's reported maximum range to be used.", -1, -1, 1000)

amcl.add("laser_max_beams", int_t, 0, "How many evenly-spaced beams in each scan to be used when updating the filter.", 30, 0, 250)

amcl.add("laser_z_hit", double_t, 0, "Mixture weight for the z_hit part of the model.", .95, 0, 1)
amcl.add("laser_z_short", double_t, 0, "Mixture weight for the z_short part of the model.", .1, 0, 1)
amcl.add("laser_z_max", double_t, 0, "Mixture weight for the z_max part of the model.", .05, 0, 1)
amcl.add("laser_z_rand", double_t, 0, "Mixture weight for the z_rand part of the model.", .05, 0, 1)
amcl.add("laser_z_reflector", double_t, 0, "Mixture weight for the z_reflector part of the model.", .95, 0, 10)

amcl.add("laser_sigma_hit", double_t, 0, "Standard deviation for Gaussian model used in z_hit part of the model.", .2, 0, 10)
amcl.add("laser_lambda_short", double_t, 0, "Exponential decay parameter for z_short part of model.", .1, 0, 10)
amcl.add("laser_likelihood_max_dist", double_t, 0, "Maximum distance to do obstacle inflation on map, for use in likelihood_field model.", 2, 0, 20)

lmt = gen.enum([gen.const("beam_const", str_t, "beam", "Use beam laser model"), gen.const("likelihood_field_const", str_t, "likelihood_field", "Use likelihood_field laser model"), gen.const("likelihood_field_prob", str_t, "likelihood_field_prob", "Use likelihood_field_prob laser model"), gen.const("likelihood_field_reflectors", str_t, "likelihood_field_reflectors", "Use likelihood_field_reflectors laser model")],"Laser Models")
amcl.add("laser_model_type", str_t, 0, "Which model to use, either beam, likelihood_field, likelihood_field_prob or likelihood_field_reflectors.", "likelihood_field_reflectors", edit_method=lmt)

# Odometry Model Parameters
odt = gen.enum([gen.const("diff_const", str_t, "diff", "Use diff odom model"),
                gen.const("omni_const", str_t, "omni", "Use omni odom model"),
                gen.const("diff_corrected_const", str_t, "diff-corrected", "Use corrected diff odom model"),
                gen.const("omni_corrected_const", str_t, "omni-corrected", "Use corrected omni odom model")],
               "Odom Models")
amcl.add("odom_model_type", str_t, 0, "Which model to use, diff, omni, diff-corrected, or omni-corrected", "diff", edit_method=odt)

amcl.add("odom_alpha1", double_t, 0, "Specifies the expected noise in odometry's rotation estimate from the rotational component of the robot's motion.", .2, 0, 10)
amcl.add("odom_alpha2", double_t, 0, "Specifies the expected noise in odometry's rotation estimate from the translational component of the robot's motion.", .2, 0, 10)
amcl.add("odom_alpha3", double_t, 0, "Specifies the expected noise in odometry's translation estimate from the translational component of the robot's motion.", .2, 0, 10)
amcl.add("odom_alpha4", double_t, 0, "Specifies the expected noise in odometry's translation  estimate from the rotational component of the robot's motion.", .2, 0, 10)
amcl.add("odom_alpha5", double_t, 0, "Translation-related noise parameter (only used if model is omni).", .2, 0, 10)


# Reflector
reflector = gen.add_group("Reflector")
reflector.add("reflector_intensity_threshold", double_t, 0, "Minimum laser intensity when reflected from the reflector surface.", 5000.0, 0)
reflector.add("reflector_far_intensity_threshold", double_t, 0, "Minimum laser intensity when reflected from the far reflector surface.", 5000.0, 0)
reflector.add("reflector_far_range_threshold", double_t, 0, "Minimum laser range (m) to use reflector_far_intensity_threshold.", 100.0, 0)
reflector.add("reflector_min_width", double_t, 0, "Minimum width (m) of the reflectors.", 0.05, 0, 0.5)
reflector.add("reflector_max_width", double_t, 0, "Maximum width (m) of the reflectors.", 0.15, 0, 0.5)
reflector.add("reflector_radius", double_t, 0, "Radius (m) of the cylinder reflectors. 0 for flat reflectors.", 0, 0, 0.5)


# Reflector Matching
rm = gen.add_group("Reflector Matching")
rm.add("match_rate", double_t, 0, "Maximum rate the reflectors will be processed for matching. Disabled if zero.", 0, 0, 100)

rm.add("match_dist_threshold", double_t, 0, "Minimum position change (m) that will trigger pose correction.", 0.01, 0.001, 1)
rm.add("match_angle_threshold", double_t, 0, "Minimum angle change (rad) that will trigger pose correction", 0.01, 0.001, 1)

rm.add("search_space_dimension", double_t, 0, "The size of the search space (m).", 8, 0.1, 20)
rm.add("search_space_resolution", double_t, 0, "The resolution of the search space (m).", 0.1, 0.01, 1)
rm.add("search_angle_offset", double_t, 0, "The range of angles to search (rad).", pi / 3, 0, 2 * pi)
rm.add("search_angle_resolution", double_t, 0, "The resolution of angles to search (rad).", pi / 36, 0.01, pi / 9)
rm.add("match_hit_tolerance", double_t, 0, "The max distance between the reflector and map landmark to consider a valid match (m).", 0.2, 0.01, 1)

rm.add("match_inlier_threshold", double_t, 0, "Fraction of scan points that must match within inlier_dist to be considered a good match.", 0.0, 0, 1)
rm.add("match_inlier_preferable_threshold", double_t, 0, "Minimum inlier improvement between the original and corrected pose to be considered a good match.", 0.0, 0, 1)


# ICP
icp = gen.add_group("ICP")

icp.add("age_threshold", double_t, 0, "Maximum age of laser scan that will be processed.", 1, 0, 10)
icp.add("scan_rate", double_t, 0, "Maximum rate the laser scans will be processed. Disabled if zero.", 2, 0, 10)

icp.add("update_age_threshold", double_t, 0, "Minimum duration between pose corrections.", 1, 0, 10)

icp.add("dist_threshold", double_t, 0, "Minimum position change that will trigger pose correction.", 0.01, 0.001, 1)
icp.add("angle_threshold", double_t, 0, "Minimum angle change that will trigger pose correction", 0.01, 0.001, 1)
icp.add("dist_upper_threshold", double_t, 0, "Maximum ICP transform distance that will still be considered a sane match.", 1, 0.001, 10)
icp.add("angle_upper_threshold", double_t, 0, "Maximum ICP transform angle that will still be considered a sane match.", 1, 0.001, 3.14)

#icp.add("icp_fitness_threshold", double_t, 0, "Minimum Euclidean fitness score to trigger pose correction.", 100, 0, 1000)
icp.add("icp_inlier_threshold", double_t, 0, "Fraction of scan points that must match within icp_inlier_dist to be considered a good match.", 0.88, 0, 1)
icp.add("icp_inlier_preferable_threshold", double_t, 0, "Minimum inlier improvement between the original and corrected pose to be considered a good match.", 0.1, 0, 1)
icp.add("icp_inlier_dist", double_t, 0, "Distance a point can have to its nearest neighbour in the map to be still considered as inlier.", 0.1, 0, 1)
icp.add("icp_num_iter", int_t, 0, "Number of iterations in ICP.", 250, 10, 1000)

icp.add("pose_covariance_trans", double_t, 0, "Translational pose covariance the correction pose gets sent with.", 0.5, 0.001, 10)


# Map Quality Score
qmap = gen.add_group("Map Score")

qmap.add("new_map_score_", bool_t, 0, "Create new map quality score.", False)
qmap.add("high_threshold", double_t, 0, "Threshold of high map quality score.", 0.75, 0, 1)
qmap.add("low_threshold", double_t, 0, "Threshold of low map quality score.", 0.5, 0, 1)


# Inlier
inlier = gen.add_group("Inlier")

inlier.add("inlier_dist", double_t, 0, "Distance a point can have to its nearest neighbour in the map to be still considered as inlier.", 0.1, 0, 1)
inlier.add("inlier_decay_dist", double_t, 0, "Decay distance (m) from sensor for inlier score. Disabled if zero.", 5, 0, 100)


# Miscellaneous
misc = gen.add_group("Misc")

misc.add("odom_frame_id", str_t, 0, "Which frame to use for odometry.", "odom")
misc.add("base_frame_id", str_t, 0, "Which frame to use for the robot base.", "base_link")
misc.add("global_frame_id", str_t, 0, "The name of the coordinate frame published by the localization system.", "map")

profiles = gen.enum([gen.const("skip", int_t, 0, "Do not load profile"),
                     gen.const("profile_1", int_t, 1, "Fast recorrection and high accuracy with bottom lidar"),
                     gen.const("profile_2", int_t, 2, "Fast recorrection and high accuracy with pole lidar"),
                     gen.const("profile_3", int_t, 3, "Slow recorrection to reduce swaying movements")],
                     "Profiles")
misc.add("load_profile_", int_t, 0, "Restore parameters from the default profile. Note that existing parameters will be overwritten", 0, edit_method=profiles)

exit(gen.generate(PACKAGE, "amcl_node", "AMCL"))
