#!/usr/bin/env python
PACKAGE = "agv05_state_filter"

from dynamic_reconfigure.parameter_generator_catkin import *
from math import pi

gen = ParameterGenerator()

gen.add("linear_error_threshold", double_t, 0, "Minimum linear error (m) per second that indicates translational slippage", 0.6, 0.01, 10)
gen.add("angular_error_threshold", double_t, 0, "Minimum angular error (deg) per second that indicates rotational slippage", 15, 0.5, 180)
gen.add("error_average_window", int_t, 0, "The number of data points to use to calculate the moving average of the error", 4, 1, 10)
gen.add("process_rate", double_t, 0, "The number of scan matching to perform per second", 4, 0.1, 100)


# CSM parameters
csm = gen.add_group("CSM")

csm.add("max_angular_correction_deg", double_t, 0, "Maximum angular displacement between scans (deg)", 45.0, 0.1, 180.0)
csm.add("max_linear_correction", double_t, 0, "Maximum translation between scans (m)", 0.5, 0.01, 10.0)

csm.add("max_iterations", int_t, 0, "Maximum ICP cycle iterations", 10, 1, 500)
csm.add("epsilon_xy", double_t, 0, "A threshold for stopping (m)", 1e-6, 0, 1)
csm.add("epsilon_theta", double_t, 0, "A threshold for stopping (rad)", 1e-6, 0, 1)

csm.add("max_correspondence_dist", double_t, 0, "Maximum distance for a correspondence to be valid (m)", 0.3, 0.001, 10)
csm.add("use_corr_tricks", bool_t, 0, "Use smart tricks for finding correspondences. Only influences speed; not convergence", True)

csm.add("restart", bool_t, 0, "Restart if error is over threshold", False)
csm.add("restart_threshold_mean_error", double_t, 0, "Threshold for restarting", 0.01, 0, 1)
csm.add("restart_dt", double_t, 0, "Displacement for restarting (m)", 1.0, 0, 10)
csm.add("restart_dtheta", double_t, 0, "Displacement for restarting (rad)", 0.1, 0, pi)


csm.add("inliers_minPerc", double_t, 0,
    "Percentage of correspondences to consider whole set output data is valid",
    0.5, 0, 1.0)
csm.add("outliers_maxPerc", double_t, 0,
    "Percentage of correspondences to consider: if 0.9, always discard the top 10% of correspondences with more error",
    0.9, 0, 1.0)
csm.add("outliers_adaptive_order", double_t, 0,
    "Parameters describing a simple adaptive algorithm for discarding. " +
    "(1) Order the errors. " +
    "(2) Choose the percentile according to outliers_adaptive_order. (if it is 0.7, get the 70% percentile). " +
    "(3) Define an adaptive threshold multiplying outliers_adaptive_mult with the value of the error at the chosen percentile. " +
    "(4) Discard correspondences over the threshold. " +
    "This is useful to be conservative; yet remove the biggest errors",
    0.7, 0, 1.0)
csm.add("outliers_adaptive_mult", double_t, 0, "see above", 2, 0, 10)
csm.add("outliers_remove_doubles", bool_t, 0, "Do not allow two different correspondences to share a point", True)

csm.add("clustering_threshold", double_t, 0, "Max distance for staying in the same clustering", 0.25, 0, 100)
csm.add("orientation_neighbourhood", int_t, 0, "Number of neighbour rays used to estimate the orientation", 20, 0, 100)

csm.add("do_alpha_test", bool_t, 0, "Discard correspondences based on the angles", False)
csm.add("do_alpha_test_thresholdDeg", double_t, 0, "Discard correspondences based on the angles - threshold angle (deg)", 20, 0, 180)

csm.add("do_visibility_test", bool_t, 0,
    "If you already have a guess of the solution, you can compute the polar angle of the points of one scan in the new position. " +
    "If the polar angle is not a monotone function of the readings index, it means that the surface is not visible in the next position. " +
    "If it is not visible, then we don't use it for matching", False)


csm.add("use_point_to_line_distance", bool_t, 0, "If true, use PL-ICP; if false, use vanilla ICP", True)

csm.add("use_ml_weights", bool_t, 0, "If true, the field \\\"true_alpha\\\" is used to compute the incidence beta, " +
    "and the factor (1/cos^2(beta)) used to weight the impact of each correspondence. " +
    "This works fabolously if doing localization, that is the first scan has no noise. " +
    "If \\\"true_alpha\\\" is not available, it uses \\\"alpha\\\".", False)

csm.add("use_sigma_weights", bool_t, 0, "If true, the field \\\"readings_sigma\\\" is used to weight the correspondence by 1/sigma^2", False)

csm.add("do_compute_covariance", bool_t, 0, "Use the method in http://purl.org/censi/2006/icpcov to compute the matching covariance", False)

csm.add("debug_verify_tricks", bool_t, 0, "Checks that find_correspondences_tricks give the right answer", False)

csm.add("sigma", double_t, 0, "Noise in the scan", 0.01, 0, 10)

#csm.add("min_reading", double_t, 0, "", 0, 0, 360)
#csm.add("max_reading", double_t, 0, "mark as invalid ( = don't use ) rays outside of this interval", 0, 0, 360)

csm.add("use_odometry_guess", bool_t, 0, "Use odometry as initial guess", True)


exit(gen.generate(PACKAGE, "agv05_state_filter", "StateFilter"))
