#!/usr/bin/env python
PACKAGE = "agv05_motor"

from dynamic_reconfigure.parameter_generator_catkin import *


gen = ParameterGenerator()

mdt = gen.enum([gen.const("differential_drive", str_t, "differential", "Use differential drive controller"),
                gen.const("tricycle_steering_drive", str_t, "tricycle_steering", "Use tricycle steering drive controller"),
                gen.const("swerve_drive", str_t, "swerve", "Use swerve drive controller"),
                gen.const("mecanum_drive", str_t, "mecanum", "Use mecanum drive controller"),
                gen.const("custom_drive", str_t, "custom", "Use custom drive controller")],
               "Drive types")
gen.add("drive_type", str_t, 0, "Change the drive controller type (soft-reboot required)", "differential", edit_method=mdt)

diff_drive = gen.add_group("Differential Drive")
diff_drive.add("left_motor_calibration", double_t, 0, "A scale to apply to the left motor distance", 1.0, 0.1, 10.0)
diff_drive.add("right_motor_calibration", double_t, 0, "A scale to apply to the right motor distance", 1.0, 0.1, 10.0)
diff_drive.add("track_width", double_t, 0, "The distance between the left wheel and the right wheel (m)", 0.5, 0.1, 2.0)
diff_drive.add("motor_feedback_window", int_t, 0, "Motor feedback window size", 1, 1, 16)

steer_drive = gen.add_group("Tricycle Steering Drive")
steer_drive.add("drive_motor_calibration", double_t, 0, "A scale to apply to the steering drive distance", 1.0, 0.1, 10.0)
steer_drive.add("wheelbase", double_t, 0, "The perpendicular distance from the front steering wheel to the rear axle (m)", 1.3845, 0.1, 10.0)
steer_drive.add("drive_center_offset", double_t, 0, "The horizontal offset from robot base to rotation center (m)", 0.0, -2.0, 2.0)
steer_drive.add("steer_angle_turn", double_t, 0, "The steering angle for on-spot turning around rotation center (deg)", 0.0, -90.0, 90.0)
steer_drive.add("steer_angle_align", double_t, 0, "The steering angle error tolerance before start moving on path (deg)", -1.0, -1.0, 180.0)

swerve_drive = gen.add_group("Swerve Drive")
swerve_drive.add("front_motor_calibration", double_t, 0, "A scale to apply to the front motor distance", 1.0, 0.1, 10.0)
swerve_drive.add("rear_motor_calibration", double_t, 0, "A scale to apply to the rear motor distance", 1.0, 0.1, 10.0)
swerve_drive.add("swerve_wheelbase", double_t, 0, "The perpendicular distance from the front wheel to the rear axle (m)", 1.3845, 0.1, 10.0)
swerve_drive.add("swerve_center_offset", double_t, 0, "The horizontal offset from robot base to front wheel (m)", 0.0, -2.0, 2.0)
swerve_drive.add("swerve_front_steer_angle_min", double_t, 0, "The minimum front steering angle (deg).", 0.0, -180.0, 180.0)
swerve_drive.add("swerve_front_steer_angle_max", double_t, 0, "The maximum front steering angle (deg). Uncapped if zero.", 0.0, 0.0, 1080.0)
swerve_drive.add("swerve_rear_steer_angle_min", double_t, 0, "The minimum rear steering angle (deg).", 0.0, -180.0, 180.0)
swerve_drive.add("swerve_rear_steer_angle_max", double_t, 0, "The maximum rear steering angle (deg). Uncapped if zero.", 0.0, 0.0, 1080.0)

mecanum_drive = gen.add_group("Mecanum Drive")
mecanum_drive.add("left_front_motor_calibration", double_t, 0, "A scale to apply to the left front motor distance", 1.0, 0.1, 10.0)
mecanum_drive.add("left_rear_motor_calibration", double_t, 0, "A scale to apply to the left rear motor distance", 1.0, 0.1, 10.0)
mecanum_drive.add("right_rear_motor_calibration", double_t, 0, "A scale to apply to the right rear motor distance", 1.0, 0.1, 10.0)
mecanum_drive.add("right_front_motor_calibration", double_t, 0, "A scale to apply to the right front motor distance", 1.0, 0.1, 10.0)
mecanum_drive.add("mecanum_wheelbase", double_t, 0, "The perpendicular distance from the front wheel to the rear wheel (m)", 1.3845, 0.1, 10.0)
mecanum_drive.add("mecanum_track_width", double_t, 0, "The horizontal distance between the left wheel and the right wheel (m)", 0.5, 0.1, 2.0)

custom_drive = gen.add_group("Custom Drive")
custom_drive.add("odom_tf_broadcast_", bool_t, 0, "True to publish odom and TF.", True)
custom_drive.add("angular_millage_gain_", double_t, 0, "A scale to apply to the angular distance in millage calculation", 0.25, 0.001, 10.0)

gen.add("max_acceleration", double_t, 0, "Maximum motor acceleration (m/s2)", 2.0, 0.001, 10.0)
gen.add("max_deceleration", double_t, 0, "Maximum motor deceleration (m/s2)", 2.0, 0.001, 10.0)
gen.add("decelerate_on_safety_trigger", bool_t, 0, "Apply deceleration when safety trigger happens to reduce jerk", True)
gen.add("velocity_timeout", double_t, 0, "Set velocity to zero if the next command is not received after timeout (s)", 0.5, 0.0, 2.0)

gen.add("motor_fault_trigger_sensitivity", double_t, 0, "Motor fault trigger sensitivity. Disabled if zero.", 0.3, 0.0, 1.0)
gen.add("motor_fault_trigger_timeout", double_t, 0, "Motor fault trigger timeout (s).", 1.0, 0.1, 10.0)
gen.add("motor_fault_trigger_min_speed", double_t, 0, "Motor fault trigger minimum speed (m/s).", 0.01, 0.0, 1.0)
gen.add("motor_fault_trigger_fir", bool_t, 0, "Enable FIR filter on motor fault trigger.", False)

gen.add("imu_odom_timeout", double_t, 0, "Skip integrating IMU data if there is no change in odometry after timeout (s). Disable IMU if zero.", 0.0, 0.0, 60.0)

exit(gen.generate(PACKAGE, "agv05_motor", "Motor"))
